<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Workflowy-Lite (No Storage)</title>
  <style>
    :root{
      --bg: #f6f8fb;
      --panel: #ffffff;
      --muted: #5b6b7b;
      --text: #0b1220;
      --soft: #f1f5fb;
      --accent: #2563eb;
      --accent-2:#16a34a;
      --danger:#e11d48;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text); background:#f6f8fb;
    }
    .app{
      height:100%; display:grid; grid-template-rows:auto auto 1fr auto; gap:6px; padding:12px; max-width:1400px; margin:0 auto;
    }
    header{
      display:flex; align-items:center; gap:8px; padding:6px 10px; background:var(--panel); border:1px solid #e2e8f0; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.06);
      position:sticky; top:8px; z-index:2;
    }
    .logo{font-weight:800; letter-spacing:.2px; font-size:14px;}
    .dot{display:inline-block; width:6px; height:6px; border-radius:50%; background:var(--accent); margin-right:4px; box-shadow:0 0 0 2px rgba(124,212,255,.2)}
    .search{
      flex:1; display:flex; align-items:center; gap:6px; background:var(--soft); border:1px solid #e2e8f0; border-radius:8px; padding:5px 8px;
    }
    .search input{ width:100%; background:transparent; color:var(--text); border:0; outline:none; font-size:13px; }
    .btn{
      appearance:none; border:1px solid #e2e8f0; background:var(--soft); color:var(--text); padding:5px 9px; border-radius:8px; cursor:pointer;
      transition:.15s transform, .15s background, .15s border-color; font-weight:600; font-size:12px;
    }
    .btn:hover{ transform:translateY(-1px); border-color:#cbd5e1 }
    .btn:active{ transform:translateY(0) scale(.98) }
    .ghost{ background:transparent }

    .toolbar{ display:flex; gap:6px; align-items:center; padding:5px 10px; background:var(--panel); border:1px solid #e2e8f0; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.05) }

    .breadcrumbs{display:flex; flex-wrap:wrap; gap:4px; align-items:center}
    .crumb{background:var(--soft); border:1px solid #e2e8f0; padding:3px 7px; border-radius:999px; cursor:pointer; font-size:12px;}
    .crumb:hover{border-color:#cbd5e1}
    .sep{opacity:.5}

    main{
      overflow:auto; padding:6px; background:var(--panel); border:1px solid #e2e8f0; border-radius:12px; box-shadow: inset 0 0 0 1px rgba(0,0,0,.02);
    }

    ul.outline{ list-style:none; padding-left:0; margin:0; }
    .li{ position:relative; display:flex; align-items:flex-start; gap:5px; padding:1px 4px; margin:1px 0; border-radius:6px; border:1px solid transparent; }
    .li.focused{ border-color:#cbd5e1; background:#f8fafc }

    /* Bullet chevron */
    .bullet{ width:16px; height:16px; margin-top:1px; border-radius:4px; background: var(--soft); border:1px solid #d5dde8; cursor:pointer; display:grid; place-items:center; flex:0 0 auto; font-size:11px; line-height:1; }
    .bullet.collapsed::after{ content:"▸"; font-weight:700; opacity:.8 }
    .bullet:not(.collapsed)::after{ content:"▾"; font-weight:700; opacity:.8 }

    .text{ flex:1; min-height:16px; outline:none; padding:1px 4px; border-radius:6px; }
    .text:empty:before{ content:attr(data-placeholder); opacity:.45 }

    /* Tight child spacing + guide lines */
    .children{ padding-left:28px; margin-top:0.25em; border-left:1px solid #e2e8f0; }
    .children .li::before{ content:""; position:absolute; left:-28px; top:10px; width:28px; height:1px; background:#e2e8f0; }
    ul.outline > .li::before{ display:none }

    .hidden{ display:none }
    .hint{ color:var(--muted); font-size:11px; padding:6px 2px; }
    .li.match{ background:#fffbe6; border-color:#fde68a }
    .li.match .text{ font-weight:600 }
    kbd{ background:#1b2433; border:1px solid #2a384e; padding:2px 4px; border-radius:4px; font-size:10px }

    .footer{ color:var(--muted); font-size:11px; display:flex; justify-content:space-between; align-items:center; padding:6px 2px }
    .muted{ color:var(--muted) }
    .pill{ background:#f1f5fb; border:1px solid #e2e8f0; padding:3px 7px; border-radius:999px; font-size:11px }
    .danger{ color:var(--danger) }
    .success{ color:var(--accent-2) }

    /* Hide file input for import */
    #importFile{ display:none }

    @media (max-width:700px){
      .app{ padding:8px; gap:4px }
      header, .toolbar{ border-radius:10px }
      .children{ padding-left:24px }
      .children .li::before{ left:-24px; width:24px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="logo"><span class="dot"></span>Workflowy-Lite</div>
      <div class="search" title="Filter (Ctrl/Cmd+K)">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
        <input id="search" placeholder="Search or jump… (Ctrl/Cmd+K)" />
      </div>
      <button class="btn" id="addRoot">+ New</button>
      <button class="btn ghost" id="expandAll" title="Expand/Collapse all">Expand all</button>

      <!-- Export / Import -->
      <button class="btn" id="exportMD" title="Export current view as Markdown">Export MD</button>
      <button class="btn" id="exportJSON" title="Export current view as JSON">Export JSON</button>
      <button class="btn" id="exportTXT" title="Export current view as plain text">Export TXT</button>
      <button class="btn" id="importBtn" title="Import into current view (appends)">Import…</button>
      <input type="file" id="importFile" accept=".json,.md,.markdown,.txt,.text" />
    </header>

    <div class="toolbar">
      <div class="breadcrumbs" id="breadcrumbs"></div>
      <div style="flex:1"></div>
      <span class="pill">No storage • session only</span>
    </div>

    <main>
      <ul id="outline" class="outline"></ul>
      <div class="hint">
        <strong>Shortcuts:</strong> <kbd>Enter</kbd> new sibling, <kbd>Tab</kbd>/<kbd>Shift+Tab</kbd> indent/outdent, <kbd>Backspace</kbd> on empty to delete, <kbd>↑/↓</kbd> move focus, click bullet to collapse, <kbd>Alt+Click</kbd> bullet to <em>zoom</em>, <kbd>Esc</kbd> back, <kbd>Ctrl/Cmd+K</kbd> search.
      </div>
    </main>

    <div class="footer">
      <div>Built fast with vanilla <span class="muted">HTML/CSS/JS</span> · <span class="success">no backend</span></div>
      <div class="muted">Inspired by Workflowy. For demo purposes only.</div>
    </div>
  </div>

  <script>
  // ------------------------------
  // Simple in-memory outliner
  // ------------------------------
  const $ = (s, el=document) => el.querySelector(s);
  const $$ = (s, el=document) => [...el.querySelectorAll(s)];

  let idCounter = 1;
  const newId = () => String(idCounter++);

  /** Tree node shape: { id, text, collapsed, children: [] } */
  const makeNode = (text="", children=[]) => ({ id:newId(), text, collapsed:false, children });

  // Seed data
  const initial = makeNode("My life outline", [
    makeNode("Projects", [
      makeNode("Workflowy-Lite clone (today)")
    ]),
    makeNode("Personal", [
      makeNode("Groceries"),
      makeNode("Books to read")
    ]),
    makeNode("Ideas")
  ]);

  // State
  let root = initial;        // absolute root (not shown in list)
  let view = root;           // current zoomed node
  let selectedId = null;     // currently focused editable node id
  let filterQuery = "";      // search query
  let expandModeAll = false; // for Expand all button toggle

  // --------------- Rendering ---------------
  function render(){
    renderBreadcrumbs();
    const list = $('#outline');
    list.innerHTML = '';

    const { nodes, matches, forceOpen } = getVisible(view, filterQuery);

    for (const n of nodes) {
      list.appendChild(renderNode(n, matches, forceOpen));
    }

    // Update expand button label
    $('#expandAll').textContent = expandModeAll ? 'Collapse all' : 'Expand all';

    // Keep selection visible
    if (selectedId){
      const el = document.querySelector(`[data-id="${selectedId}"]`);
      if (el) el.scrollIntoView({ block:'nearest' });
    }
  }

  function renderBreadcrumbs(){
    const bc = $('#breadcrumbs');
    bc.innerHTML = '';
    const chain = pathToNode(view.id);
    chain.forEach((node, i) => {
      const span = document.createElement('span');
      span.className = 'crumb';
      span.textContent = i === 0 ? 'Home' : node.text || '(empty)';
      span.title = 'Jump to ' + (i===0 ? 'Home' : node.text || '(empty)');
      span.onclick = () => { view = node; selectedId = null; render(); };
      bc.appendChild(span);
      if (i < chain.length - 1){
        const sep = document.createElement('span'); sep.className='sep'; sep.textContent='›'; bc.appendChild(sep);
      }
    });
  }

  function renderNode(node, matches, forceOpen){
    const li = document.createElement('li');
    li.className = 'li';

    const bullet = document.createElement('button');
    const isForcedOpen = forceOpen && forceOpen.has(node.id);
    bullet.className = 'bullet' + ((node.collapsed && !isForcedOpen) ? ' collapsed' : '');
    bullet.title = 'Click: collapse • Alt+Click: zoom into';
    bullet.onclick = (e) => {
      if (e.altKey){ view = node; selectedId = null; render(); return; }
      node.collapsed = !node.collapsed; render();
    };

    const text = document.createElement('div');
    text.className = 'text';
    text.contentEditable = true;
    text.dataset.id = node.id;
    text.setAttribute('spellcheck','false');
    text.setAttribute('data-placeholder','List item');
    text.textContent = node.text;

    text.addEventListener('focus', () => focusNode(node.id, li));
    text.addEventListener('input', () => { node.text = text.textContent; });

    text.addEventListener('keydown', (e) => handleEditorKeys(e, node));

    li.appendChild(bullet);
    li.appendChild(text);

    // children
    const kids = document.createElement('div'); kids.className = 'children';
    if (node.children.length) {
      const childList = document.createElement('ul'); childList.className='outline';
      const isClosed = node.collapsed && !(forceOpen && forceOpen.has(node.id));
      if (isClosed) childList.classList.add('hidden');
      for (const c of node.children){
        childList.appendChild(renderNode(c, matches, forceOpen));
      }
      kids.appendChild(childList);
    }

    li.appendChild(kids);

    // highlight if selected
    if (selectedId === node.id) li.classList.add('focused');

    // mark match & hide if filtered out
    if (matches && matches.has(node.id)) li.classList.add('match');
    if (matches && !matches.has(node.id)) li.classList.add('hidden');

    return li;
  }

  function focusNode(id, liEl){
    selectedId = id;
    $$('.li').forEach(li => li.classList.remove('focused'));
    if (liEl) liEl.classList.add('focused');
  }

  // --------------- Filtering ---------------
  function getVisible(rootNode, query){
    if (!query) return { nodes: rootNode.children, matches: null, forceOpen: null };
    query = query.toLowerCase();
    const matches = new Set();
    const forceOpen = new Set();

    function dfs(node, ancestors){
      const hit = (node.text || '').toLowerCase().includes(query);
      if (hit){
        matches.add(node.id);
        ancestors.forEach(a => { matches.add(a.id); forceOpen.add(a.id); });
      }
      if (!node.children) return;
      for (const c of node.children) dfs(c, hit ? [node, ...ancestors] : ancestors);
    }
    dfs(rootNode, []);

    return { nodes: rootNode.children, matches, forceOpen };
  }

  // --------------- Keyboard actions ---------------
  function handleEditorKeys(e, node){
    const current = e.currentTarget;
    if (e.key === 'Enter'){
      e.preventDefault();
      insertSibling(node, /*after*/true);
      return;
    }
    if (e.key === 'Tab'){
      e.preventDefault();
      if (e.shiftKey) outdent(node); else indent(node);
      return;
    }
    if (e.key === 'Backspace'){
      const txt = current.textContent.trim();
      if (!txt){
        e.preventDefault();
        deleteNode(node);
      }
      return;
    }
    if (e.key === 'ArrowUp' || e.key === 'ArrowDown'){
      e.preventDefault();
      moveFocus(node.id, e.key === 'ArrowDown');
      return;
    }
    if (e.key === 'Escape'){
      // zoom out one level if possible
      const chain = pathToNode(node.id);
      if (chain.length > 1){ view = chain[chain.length - 2]; selectedId = null; render(); }
      return;
    }
  }

  function linearizeVisible(){
    const arr = [];
    function walk(nodes){
      for (const n of nodes){
        arr.push(n);
        if (!n.collapsed && n.children.length) walk(n.children);
      }
    }
    walk(view.children);
    return arr;
  }

  function moveFocus(id, forward=true){
    const list = linearizeVisible();
    const idx = list.findIndex(n => n.id === id);
    const next = list[idx + (forward ? 1 : -1)];
    if (next){
      selectedId = next.id; render();
      requestAnimationFrame(() => {
        const el = document.querySelector(`[data-id="${next.id}"]`);
        if (el){ el.focus(); placeCaretAtEnd(el); }
      });
    }
  }

  function placeCaretAtEnd(el){
    const range = document.createRange();
    const sel = window.getSelection();
    range.selectNodeContents(el);
    range.collapse(false);
    sel.removeAllRanges(); sel.addRange(range);
  }

  // --------------- Tree Ops ---------------
  function findParentAndIndex(targetId, node=view){
    const kids = node.children;
    for (let i=0;i<kids.length;i++){
      const k = kids[i];
      if (k.id === targetId) return { parent: node, index: i };
      if (k.children.length){
        const deeper = findParentAndIndex(targetId, k);
        if (deeper) return deeper;
      }
    }
    return null;
  }

  function insertSibling(node, after){
    const ref = findParentAndIndex(node.id, view);
    if (!ref) return;
    const { parent, index } = ref;
    const newNode = makeNode("");
    parent.children.splice(index + (after?1:0), 0, newNode);
    render();
    requestAnimationFrame(() => {
      const el = document.querySelector(`[data-id="${newNode.id}"]`);
      if (el){ el.focus(); }
      selectedId = newNode.id;
    });
  }

  function deleteNode(node){
    const ref = findParentAndIndex(node.id, view);
    if (!ref) return;
    const { parent, index } = ref;
    parent.children.splice(index,1);
    render();
    // focus previous visible
    const flat = linearizeVisible();
    const prev = flat[Math.max(0, flat.findIndex(n => n.id===node.id) - 1)] || parent;
    const targetId = prev.id || (prev.children[0] && prev.children[0].id);
    if (targetId){
      const el = document.querySelector(`[data-id="${targetId}"]`);
      if (el){ el.focus(); }
      selectedId = targetId;
    }
  }

  function indent(node){
    const ref = findParentAndIndex(node.id, view);
    if (!ref) return;
    const { parent, index } = ref;
    if (index === 0) return; // can't indent first child
    const prevSibling = parent.children[index - 1];
    // move node under previous sibling
    parent.children.splice(index,1);
    prevSibling.children.push(node);
    prevSibling.collapsed = false;
    render();
    requestAnimationFrame(() => {
      const el = document.querySelector(`[data-id="${node.id}"]`);
      if (el){ el.focus(); }
    });
  }

  function outdent(node){
    const ref = findParentAndIndex(node.id, view);
    if (!ref) return;
    const { parent } = ref;
    const up = findParentAndIndex(parent.id, view);
    if (!up) return; // already at top of view
    // remove from parent
    const idx = parent.children.findIndex(c => c.id === node.id);
    parent.children.splice(idx,1);
    // insert after parent in its parent
    const { parent: grand, index: pIdx } = up;
    grand.children.splice(pIdx + 1, 0, node);
    render();
    requestAnimationFrame(() => {
      const el = document.querySelector(`[data-id="${node.id}"]`);
      if (el){ el.focus(); }
    });
  }

  // --------------- Utilities ---------------
  function pathToNode(id){
    const chain = [root];
    function dfs(node){
      if (node.id === id){ chain.push(node); return true; }
      for (const c of node.children){
        chain.push(c);
        if (c.id === id) return true;
        if (dfs(c)) return true;
        chain.pop();
      }
      chain.pop();
      return false;
    }
    if (id !== root.id) dfs(root);
    // trim to path only
    const path = [];
    const seen = new Set();
    for (const n of chain){ if (!seen.has(n)) { path.push(n); seen.add(n);} }
    // ensure starts with root and ends with view
    const idxView = path.findIndex(n => n.id === view.id);
    return idxView >= 0 ? path.slice(0, idxView + 1) : [root];
  }

  // --------------- Search ---------------
  const search = $('#search');
  search.addEventListener('input', (e)=>{ filterQuery = e.target.value.trim(); render(); });
  window.addEventListener('keydown', (e)=>{
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='k'){
      e.preventDefault(); search.focus(); search.select();
    }
  });

  // --------------- Top bar actions ---------------
  $('#addRoot').onclick = () => {
    const n = makeNode("");
    view.children.push(n);
    render();
    requestAnimationFrame(()=>{
      const el = document.querySelector(`[data-id="${n.id}"]`); if (el){ el.focus(); }
    });
  };

  $('#expandAll').onclick = () => {
    expandModeAll = !expandModeAll;
    function setAll(nodes, val){ for (const n of nodes){ n.collapsed = !val; if (n.children.length) setAll(n.children, val); } }
    setAll(view.children, expandModeAll);
    render();
  };

  // --------------- Export / Import ---------------
  function toJSON(node){
    const clone = ({ text, collapsed, children }) => ({ text, collapsed, children: (children||[]).map(clone) });
    return clone(node);
  }

  function toMarkdown(node){
    const lines = [];
    const walk = (nodes, depth=0) => {
      for (const n of nodes){
        const t = (n.text || '').replace(/\s+/g,' ').trim();
        lines.push(`${'  '.repeat(depth)}- ${t}`);
        if (n.children && n.children.length) walk(n.children, depth+1);
      }
    };
    walk(node.children, 0);
    return lines.join('\n');
  }

  function toText(node){
    const lines = [];
    const walk = (nodes, depth=0) => {
      for (const n of nodes){
        const t = (n.text || '').replace(/\s+/g,' ').trim();
        lines.push(`${'  '.repeat(depth)}${t}`);
        if (n.children && n.children.length) walk(n.children, depth+1);
      }
    };
    walk(node.children, 0);
    return lines.join('\n');
  }

  function download(name, content, mime){
    const blob = new Blob([content], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = name; document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  document.getElementById('exportMD').onclick = () => download('workflowy-lite.md', toMarkdown(view), 'text/markdown');
  document.getElementById('exportJSON').onclick = () => download('workflowy-lite.json', JSON.stringify(toJSON(view), null, 2), 'application/json');
  document.getElementById('exportTXT').onclick = () => download('workflowy-lite.txt', toText(view), 'text/plain');

  document.getElementById('importBtn').onclick = () => document.getElementById('importFile').click();
  document.getElementById('importFile').addEventListener('change', handleImport, false);

  function handleImport(evt){
    const file = evt.target.files[0]; if (!file) return;
    const ext = (file.name.split('.').pop() || '').toLowerCase();
    const reader = new FileReader();
    reader.onload = () => {
      const text = String(reader.result || '');
      let nodes = [];
      try{
        if (ext === 'json' || text.trim().startsWith('{') || text.trim().startsWith('[')){
          nodes = importFromJSON(text);
        } else if (ext === 'md' || ext === 'markdown'){
          nodes = importFromMarkdown(text);
        } else {
          nodes = importFromText(text);
        }
      } catch(e){
        alert('Import failed: ' + (e && e.message ? e.message : e));
        return;
      }
      view.children.push(...nodes);
      render();
      evt.target.value = '';
    };
    reader.readAsText(file);
  }

  function importFromJSON(raw){
    const data = JSON.parse(raw);
    const normalize = (o) => makeNode(String(o.text||''), (o.children||[]).map(normalize));
    if (Array.isArray(data.children)) return data.children.map(normalize);
    if (Array.isArray(data)) return data.map(normalize);
    if (data && typeof data === 'object') return [normalize(data)];
    return [];
  }

  function importFromMarkdown(raw){
    const lines = raw.split(/\r?\n/).filter(l=>l.trim().length);
    return parseIndentedLines(lines, true);
  }

  function importFromText(raw){
    const lines = raw.split(/\r?\n/).filter(l=>l.trim().length);
    return parseIndentedLines(lines, false);
  }

  function parseIndentedLines(lines, isMarkdown){
    const rootTmp = makeNode('root');
    const stack = [{ level: -1, node: rootTmp }];

    const getLevel = (line) => {
      let i=0, spaces=0;
      while (i < line.length && (line[i] === ' ' || line[i] === '\t')){ spaces += (line[i] === '\t' ? 2 : 1); i++; }
      return Math.floor(spaces/2); // 2 spaces per level
    };

    const clean = (line) => {
      line = line.replace(/^\s+/, '');
      if (isMarkdown) line = line.replace(/^[*+-]\s+/, '');
      return line.trim();
    };

    for (let raw of lines){
      const level = getLevel(raw);
      const text = clean(raw);
      const node = makeNode(text);
      while (stack.length && level <= stack[stack.length-1].level){ stack.pop(); }
      stack[stack.length-1].node.children.push(node);
      stack.push({ level, node });
    }
    return rootTmp.children;
  }

  // --------------- Boot ---------------
  render();

  // Focus the first item on load for quick typing
  setTimeout(()=>{
    const first = document.querySelector('.text'); if (first){ first.focus(); }
  }, 50);
  </script>
</body>
</html>
